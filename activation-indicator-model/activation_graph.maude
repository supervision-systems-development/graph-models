*** Definition of Node types ***
fmod NTYPE is
  
  sort NType .
  ops nseq nand nor nxor : -> NType [ctor] .

endfm

*** Definition of execution status ***
fmod STATUS is

  sort Status .
  ops starting correct incorrect executing  : -> Status [ctor] .

endfm

*** Definition of a Graph ***
fmod GRAPH is
  pr NAT .
  pr INT .
  pr STRING .
  pr NTYPE .
  pr STATUS .

  --- Definition of a Graph
  sort Graph .
  op nil : -> Graph [ctor] .
  op _;;_ : Graph Graph -> Graph [assoc comm id: nil prec 50 ] .

  --- Definition of Nodes
  sort Node .
  ---subsort Node < Graph .
  op (n[_]:_) : Int NType -> Node [ctor prec 30] . --- Definition of Node. Has Id, Type and Function

  --- Definition of Arcs
  sort Arc .
  subsort Arc < Graph .
 --- op arcnil : -> Arc .
  op _->_ : Node Node -> Arc [ctor prec 30] . --- Definition of Arc. Unites two nodes.

  --- Definition of actions
  sort Action .
  subsort Action < ActionList .
  op (a[_]) : Int -> Action [ctor prec 30] . --- Definition of Action. Has Id

  --- Definition of a List of Actions
  sort ActionList .
  subsort ActionList < Graph . --- Definition of ActionList. List of Actions should be part of Graph
  op nil : -> ActionList [ctor] . 
  op _;_ : ActionList ActionList -> ActionList [assoc id: nil prec 30] . --- Definition of List of Actions.

  --- 
  sort Indicator .
  subsort Indicator < IndicatorList .
  op (i[_]:_) : Int Int -> Indicator [ctor prec 30] . --- Definition of Activation Indicator. Has Id of action and Indicator value (0, 1, -1) 

  ---
  sort IndicatorList .
  op nil : -> IndicatorList [ctor] .
  op _;_ : IndicatorList IndicatorList -> IndicatorList [assoc comm id: nil prec 30 ] .
  
endfm

*** Pre-defined graphs and sequences ***
fmod SEQUENCES is
  pr GRAPH .

  *** Graph configurations for testing ***
  --- Sequential graph
  op graph1 : -> Graph .
  eq graph1 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[2]: nseq) ->(n[-7]: nseq) .

  --- Sequential graph
  op graph2 : -> Graph .
  eq graph2 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nseq) ;;
    (n[3]: nseq) ->(n[4]: nseq) ;;
    (n[4]: nseq) ->(n[-7]: nseq) .
  
  --- And graph
  op graph3 : -> Graph .
  eq graph3 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nand) ;;
    (n[3]: nseq) ->(n[4]: nand) ;;
    (n[4]: nand) ->(n[-7]: nseq) .

  --- Or graph
  op graph4 : -> Graph .
  eq graph4 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nor) ;;
    (n[3]: nseq) ->(n[4]: nor) ;;
    (n[4]: nor) ->(n[-7]: nseq) .

  --- Xor graph
  op graph5 : -> Graph .
  eq graph5 = 
  	(n[-5]: nseq) ->(n[1]: nxor) ;;
    (n[1]: nxor) ->(n[2]: nseq) ;;
    (n[1]: nxor) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nseq) ;;
    (n[3]: nseq) ->(n[4]: nseq) ;;
    (n[4]: nseq) ->(n[-7]: nseq) .
  
  --- Xor graph
  op graph6 : -> Graph .
  eq graph6 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nxor) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nxor) ->(n[4]: nseq) ;;
    (n[3]: nseq) ->(n[2]: nxor) ;;
    (n[3]: nseq) ->(n[4]: nseq) ;;
    (n[4]: nseq) ->(n[-7]: nseq) .

  --- Xor graph
  op xorTestingGraph : -> Graph .
  eq xorTestingGraph = 
    (n[1]: nseq) -> (n[2]: nseq) ;;
    (n[2]: nseq) -> (n[3]: nxor) ;;
    (n[3]: nxor) -> (n[4]: nseq) ;;
    (n[3]: nxor) -> (n[5]: nseq) ;;
    (n[5]: nseq) -> (n[6]: nor) ;;
    (n[4]: nseq) -> (n[6]: nor) ;;
    (n[6]: nor) -> (n[7]: nseq) ;;
    (n[6]: nor) -> (n[2]: nseq) .
  
  --- Graph with loop
  op smallLoopGraph : -> Graph .
  eq smallLoopGraph = 
    (n[-5]: nseq) ->(n[1]: nor) ;;
    (n[1]: nor) ->(n[2]: nseq) ;;
    (n[2]: nseq) ->(n[1]: nor) ;;
    (n[2]: nseq) ->(n[-7]: nseq) .

  --- Graph with loop
  op graphLoop : -> Graph .
  eq graphLoop = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nseq) ;;
    (n[3]: nseq) ->(n[4]: nseq) ;;
    (n[4]: nseq) ->(n[5]: nseq) ;;
    (n[5]: nseq) ->(n[6]: nseq) ;;
    (n[6]: nseq) ->(n[-7]: nseq) ;;
    (n[5]: nseq) ->(n[1]: nseq) .
  
  --- Graph with loop
  op multiLoopGraph : -> Graph .
  eq multiLoopGraph =
  	(n[-5]: nseq) -> (n[1]: nseq) ;;
    (n[1]: nseq) -> (n[2]: nseq) ;;
    (n[1]: nseq) -> (n[3]: nor) ;;
    (n[2]: nseq) -> (n[4]: nseq) ;;
    (n[3]: nor) -> (n[4]: nseq) ;;
    (n[4]: nseq) -> (n[5]: nseq) ;;
    (n[5]: nseq) -> (n[6]: nor) ;;
    (n[6]: nor) -> (n[-7]: nseq) ;;
    (n[5]: nseq) -> (n[1]: nseq) ;;
    (n[6]: nor) -> (n[8]: nseq) ;;
    (n[8]: nseq) -> (n[9]: nseq) ;;
    (n[9]: nseq) -> (n[6]: nor) ;;
    (n[8]: nseq) -> (n[3]: nor) .
  
  ---
  op andGraph : -> Graph .
  eq andGraph =
    (n[-5]: nseq) -> (n[1]: nseq) ;;
    (n[1]: nseq) -> (n[2]: nseq) ;;
    (n[1]: nseq) -> (n[3]: nseq) ;;
    (n[2]: nseq) -> (n[4]: nand) ;;
    (n[3]: nseq) -> (n[4]: nand) ;;
    (n[4]: nand) -> (n[-7]: nseq) .

  ---
  op xorGraph : -> Graph .
  eq xorGraph =
    (n[-5]: nseq) -> (n[1]: nxor) ;;
    (n[1]: nxor) -> (n[2]: nseq) ;;
    (n[1]: nxor) -> (n[3]: nseq) ;;
    (n[2]: nseq) -> (n[4]: nseq) ;;
    (n[3]: nseq) -> (n[4]: nseq) ;;
    (n[4]: nseq) -> (n[-7]: nseq) .

  op grapTest0 : -> Graph .
  eq grapTest =
    (n[-5]: nseq) -> (n[1]: nseq) ;;
    (n[1]: nseq) -> (n[5]: nseq) ;;
    (n[5]: nseq) -> (n[8]: nseq) ;;
    (n[8]: nseq) -> (n[2]: nor) ;;
    (n[2]: nor) -> (n[3]: nseq) ;;
    (n[3]: nseq) -> (n[6]: nseq) ;;
    (n[6]: nseq) -> (n[11]: nseq) ;;
    (n[11]: nseq) -> (n[-7]: nseq) .
  
  op grapTest1 : -> Graph .
  eq grapTest1 =
    (n[-5]: nseq) -> (n[1]: nseq) ;;
    (n[1]: nseq) -> (n[5]: nseq) ;;
    (n[5]: nseq) -> (n[8]: nseq) ;;
    (n[8]: nseq) -> (n[2]: nor) ;;
    (n[2]: nor) -> (n[3]: nseq) ;;
    (n[3]: nseq) -> (n[6]: nseq) ;;
    (n[6]: nseq) -> (n[4]: nseq) ;;
    (n[4]: nseq) -> (n[2]: nor) ;;
    (n[6]: nseq) -> (n[11]: nseq) ;;
    (n[11]: nseq) -> (n[-7]: nseq) .

  *** Action sequences for testing ***
  op seq1 : -> ActionList .
  eq seq1 = (a[-5]) ; (a[1]) ; (a[2]) ; (a[-7]) .

  op seq2 : -> ActionList .
  eq seq2 = (a[-5]) ; (a[1]) ; (a[-7]) .

  op seq3 : -> ActionList .
  eq seq3 = (a[-5]) ; (a[1]) ; (a[2]) ; (a[3]) ; (a[4]) ; (a[-7]) .

  op seq4 : -> ActionList .
  eq seq4 = (a[-5]) ; (a[1]) ; (a[2]) ; (a[4]) ; (a[-7]) .

  op seqTest : -> ActionList .
  eq seqTest = (a[-5]) ; (a[1]) ; (a[5]) ; (a[8]) ; (a[2]) ; (a[3]) ; (a[6]) ; (a[9]) ; (a[4]) ; (a[2]) ; (a[3]) ; (a[6]) ; (a[9]) ;  (a[4]) ;  (a[2]) ;   (a[3]) ; (a[6]) ; (a[9]) ; (a[4]) ; (a[2]) ;    (a[3]) ; (a[6]) ; (a[9]) ; (a[11]) ; (a[-7]) .

  ***
  op allInd : -> IndicatorList .
  eq allInd = (i[-5]: 1) ; (i[1]: 1) ; (i[2]: 1) ; (i[3]: 1) .

  op someInd : -> IndicatorList .
  eq someInd = (i[-5]: 1) ; (i[1]: 1) ; (i[2]: 1) .
  
endfm

*** Initial configurations ***
fmod CONFIG is
  pr SEQUENCES .

  *** Declaration of the configuration of our states ***
  sort Config .
  --- The configuration contains the following:
  --- List of actions performed
  --- List of activation indicators
  --- List of correctly performed actions
  --- List of incorrectly performed actions
  --- The sequence graph
  --- Indicator of the state of the execution
  op _|_|_|_|_|_ : ActionList IndicatorList ActionList ActionList Graph Status -> Config [ctor] . 

  *** Initial configurations using simple actions and graphs ***
  --- Sequential nodes (with artificial S and F nodes in a correct sequence) 
  op init-simple-correct : -> Config .
  eq init-simple-correct = 
    seq3 | 
    nil | 
    nil |
    nil |
    graph2 |
    starting .
endfm

fmod GRAPH-EQ is
  pr CONFIG .
  pr EXT-BOOL .

  *** Variables ***
  var AList AList' : ActionList . --- Lists of user actions
  var IList IList' : IndicatorList . --- Lists of Indicators
  var CList CList' : ActionList . --- Lists of correct actions
  var EList EList' : ActionList . --- Lists of incorrect actions
  var G G' G1 G2 : Graph . --- Graphs
  var type type' : NType . --- Node types
  var x y z n m : Int . --- Node ids

  *** Equations ***
  --- Activates indicator if not already active
  op activateIndicator : Int IndicatorList -> IndicatorList .
  eq activateIndicator(x, IList) = 
    if (i[x]: 1) in IList
    then 
      IList
    else 
      if (i[x]: -1) in IList --- If blocked, keep blocked
      then
        IList
      else 
        (i[x]: 1) ; IList
      fi
    fi .

  --- Return how many parents are in list of correct actions
  op activeParents : Action IndicatorList Graph -> String .
  eq activeParents((a[x]), IList, G) =
    if allIndicatorsActive(parents((a[x]), G), IList) == true
    then 
      "all"
    else 
      if someIndicatorsActive(parents((a[x]), G), IList) == true
      then "some"
      else "none"
      fi
    fi .

  --- If parent is XOR, block parent and sibling indicators in Indicator List
  op blockIndicatorList : Action IndicatorList Graph -> IndicatorList .
  eq blockIndicatorList((a[x]), nil, G) = nil .
  eq blockIndicatorList((a[x]), (i[n]: y) ; IList, G) = 
    if x == n
    then 
      blockList(getXORParents((a[x]), parents((a[x]), G), G), (i[n]: y) ; IList) ;
      blockList(getAllSiblings((a[x]), parents((a[x]), G), G), (i[n]: y) ; IList) ;
      IList ; getIndicator((a[x]), (i[n]: y) ; IList)
    else 
      blockIndicatorList((a[x]), IList, G)
    fi .

  --- Check if the node is starting (-5) or fin (-7). If neither, is considered "other"
  op checkFunction : Action Graph -> String . 
  eq checkFunction((a[x]), G1 ;; (n[x]: type) -> (n[y]: type') ;; G2) = 
  	if x == -5
    then "start"
    else 
      if x == -7
      then "fin"
      else "oth"
      fi
    fi .
  
  --- Check if node is type "sequential", "and", "or" or "xor"
  op checkType : Action Graph -> String .
  eq checkType((a[x]), G1 ;; (n[x]: type) -> (n[y]: type') ;; G2) =
    if type == nand
    then "and"
    else 
      if type == nor
      then "or"
      else
        if type == nxor
        then "xor"
        else "seq"
        fi
      fi
    fi .

  ---
  op isBlocked : Action IndicatorList -> Bool .
  eq isBlocked((a[x]), nil) = false .
  eq isBlocked((a[x]), IList) = 
    if (i[x]: -1) in IList
    then true
    else false
    fi .

  ---
  op isParentBlocked : Action IndicatorList Graph -> Bool .
  eq isParentBlocked((a[x]), nil, G) = false .
  eq isParentBlocked((a[x]), (i[n]: y) ; IList, G) = 
    if (n == -1) and (a[n]) in parents((a[x]), G)
    then true
    else isParentBlocked((a[x]), IList, G)
    fi .

  ---
  op isParentXOR : Action Graph -> Bool .
  eq isParentXOR((a[x]), G) =
    if isXorInList(parents((a[x]), G), G)
    then true
    else false
    fi .

  *** Auxiliary Equations ***
   --- Check if all actions are in the target list of active actions
  op allIndicatorsActive : ActionList IndicatorList -> Bool .
  eq allIndicatorsActive(nil, IList) = true .
  eq allIndicatorsActive(((a[x]) ; AList), IList) =
    (not getIndicator((a[x]), IList) == (i[x]: 0)) and (getIndicator((a[x]), IList) in IList) and allIndicatorsActive(AList, IList) .
  
  ---
  op blockIndicator : Indicator -> Indicator .
  eq blockIndicator((i[x]: y)) = (i[x]: -1) .

   ---
  op blockList : ActionList IndicatorList -> IndicatorList .
  eq blockList(nil, IList) = nil .
  eq blockList((a[x]) ; AList, (i[n]: y) ; IList) =
   if x == n
   then blockIndicator(getIndicator((a[x]), (i[n]: y) ; IList)) ; blockList(AList, IList) 
   else blockList(AList, (i[n]: y) ; IList) 
   fi .

  op test : ActionList IndicatorList -> Bool .
  eq test ((a[x]) ; AList, (i[n]: y) ; IList) =
    if x == n
    then true
    else false
    fi .


  --- To obtain the list of direct children of a node in a graph.
  op children : Action Graph -> ActionList .
  eq children((a[x]), (n[x]: type) -> (n[y]: type') ;; G) =
    (a[y]) ; children((a[x]), G) .
  eq children((a[x]), G) = nil [owise] .

  --- Action in List of Actions 
  op _in_ : Action ActionList -> Bool .
  eq (a[x]) in (AList ; (a[x]) ; AList') = true .
  eq (a[x]) in AList = false [owise] .

  --- Indicator in List of Indicators
  op _in_ : Indicator IndicatorList -> Bool .
  eq (i[x]: y) in (IList ; (i[x]: y) ; IList') = true .
  eq (i[x]: y) in IList = false [owise] .

  --- Check if the indicator is set to 1
  op isActive : Indicator -> Bool .
  eq isActive((i[x]: y)) =
    if y == 1
    then true
    else false
    fi .

  --- For each parent of the selected action, get the list of children and remove the selected action from the list to obtain its siblings
  op getAllSiblings : Action ActionList Graph -> ActionList .
  eq getAllSiblings((a[x]), nil, G) = nil .
  eq getAllSiblings((a[x]), (a[n]) ; AList, G) =
    removeAction((a[x]), children((a[n]), G)) ; getAllSiblings((a[x]), AList, G) .

  --- Get the corresponding indicator to an action. If not in list, return indicator as inactive (0)
  op getIndicator : Action IndicatorList -> Indicator .
  eq getIndicator((a[x]), IList ; (i[x]: y) ; IList') = (i[x]: y) .
  eq getIndicator((a[x]), IList) = (i[x]: 0) [owise] .

  ---
  op getXORParents : Action ActionList Graph -> ActionList .
  eq getXORParents((a[x]), nil, G) = nil .
  eq getXORParents((a[x]), (a[n]) ; AList, G) =
    if checkType((a[n]), G) == "xor"
    then (a[n]) ; getXORParents((a[x]), AList, G)
    else getXORParents((a[x]), AList, G)
    fi .

  --- Check if there is an XOR node in the graph that is performed as an action
  op isXorInList : ActionList Graph -> Bool .
  eq isXorInList(nil , G) = false .
  eq isXorInList((a[x]) ; AList, G ) = 
    checkType(a[x], G) == "xor" or isXorInList(AList, G) .
  
  --- To obtain the list of direct parents of a node in a graph. -- returns parents
  op parents : Action Graph -> ActionList .
  eq parents((a[x]), (n[y]: type') -> (n[x]: type) ;; G) =
    (a[y]) ; parents((a[x]), G) .
  eq parents((a[x]), G) = nil [owise] .

  --- Remove inactive indicator to substitute for active indicator
  op removeInactive : Int IndicatorList -> IndicatorList .
  eq removeInactive(x, (i[x]: y) ; IList) = 
    if y == 0
    then IList
    else (i[x]: y) ; IList
    fi .

  --- Remove action from list of actions
  op removeAction : Action ActionList -> ActionList .
  eq removeAction((a[x]), nil) = nil .
  eq removeAction((a[x]), (a[n]) ; AList) =
    if (a[x]) == (a[n]) 
    then AList
    else (a[n]) ; removeAction((a[x]), AList)
    fi .

  --- Check if at least one of the actions is in the target list of active actions
  op someIndicatorsActive : ActionList IndicatorList -> Bool .
  eq someIndicatorsActive(nil, IList) = false .
  eq someIndicatorsActive(((a[x]) ; AList), IList) =
    (not getIndicator((a[x]), IList) == (i[x]: 0)) and (getIndicator((a[x]), IList) in IList) or someIndicatorsActive(AList, IList) .

endfm

mod GRAPH-RL is
  pr GRAPH-EQ .
  inc CONFIG .

  *** Variables ***
  var AList AList' : ActionList . --- Lists of user actions
  var IList IList' : IndicatorList . --- Lists of Indicators
  var CList CList' CList1 CList2 : ActionList . --- Lists of correct actions
  var EList EList' EList1 EList2 : ActionList . --- Lists of incorrect actions
  var G G' : Graph . --- Graphs
  var type type' : NType . --- Node types
  var x y z : Int . --- Node ids

  *** Rules ***
  --- Start the execution: Transition status from "starting" to "executing" and consume starting action
  --- Actions start and fin are artificially inserted to control the sequences
  rl [start]: 
    (a[x]) ; AList | nil | nil | nil | G | starting  
    => 
    if checkFunction((a[x]), G) == "start"
    then
      AList | activateIndicator(x, nil) | (nil ; (a[x])) | nil | G | executing
	  else 
      AList | nil | nil | (nil ; (a[x])) | G | starting 
    fi .

  --- End the execution: Transition status from "executing" to "correct" or "incorrect"
  --- Check if the "fin" node is in the "CList" (correct list) and if so, set status as "correct"
  rl [end]:  
    nil | IList | CList ; (a[x]) | EList | G | executing
    =>
    if checkFunction((a[x]), G) == "fin"
    then
      nil | IList | CList | EList | G | correct 
    else 
      nil | IList | CList | EList | G | incorrect
    fi .
  
  ---
  rl [step] :
  (a[x]) ; AList | IList | CList | EList | G | executing
  => 
  if not (isParentBlocked((a[x]), IList, G)) and not (isBlocked((a[x]), IList)) and not (activeParents((a[x]), IList, G) == "none")
  then
    if not (isParentXOR((a[x]), G))
    then
      ---if not (parentIndicatorActive()) then *** Detect loop or repeated action
        if checkType((a[x]), G) == "and" and activeParents((a[x]), IList, G) == "all"
        then 
          AList | IList ; (i[x]: 1) | (CList ; (a[x])) | EList | G | executing 
        else
          if not (checkType((a[x]), G) == "and") and activeParents((a[x]), IList, G) == "some"
          then 
            AList | IList ; (i[x]: 1) | (CList ; (a[x])) | EList | G | executing 
          else
            AList | IList | CList | (EList ; (a[x])) | G | executing 
          fi
        fi 
      ---fi
    else *** If parent is XOR, block parent and sibling indicators
       ---if not (parentIndicatorActive()) then *** Detect loop or repeated action
        if checkType((a[x]), G) == "and" and activeParents((a[x]), IList, G) == "all"
        then 
          AList | IList | (CList ; (a[x])) | EList | G | executing 
        else
          if not (checkType((a[x]), G) == "and") and activeParents((a[x]), IList, G) == "some"
          then 
            AList | IList | (CList ; (a[x])) | EList | G | executing 
          else
            AList | IList | CList | (EList ; (a[x])) | G | executing 
          fi
        fi 
      ---fi
    fi
  else
    AList | IList | CList | (EList ; (a[x])) | G | executing 
  fi .
endm

--- Things I have to check:
--- If parent is XOR
--- Have I already been executed: If I am starting a loop or I am incorrectly executed

--- Assume simplest path as default:
--- parent is SEQ and not blocked
--- I am not blocked
--- Not been executed before (no loop and not incorrectly performed)
--- Check if I am AND, OR or XOR

*** Testing functions ***
---red checkType((a[4]), andGraph) .
---red checkType((a[4]), andGraph) == "and" .
---red not (checkType((a[3]), andGraph) == "and") .
---red not (getIndicator((a[3]), someInd) == (i[3]: 0)) .
---red parents((a[4]), andGraph) .
---red allIndicatorsActive((a[3]), someInd) .
---red someIndicatorsActive((a[3]), someInd) .
---red activeParents((a[4]), someInd, andGraph) .
---red isBlocked((a[1]), allInd) .
---red isParentBlocked((a[2]), (i[-5]: 1) ; (i[1]: -1), andGraph) .
---red isXorInList((a[1]) ; (a[2]), xorGraph) .
---red isParentXOR((a[3]), xorGraph) .
---red removeAction((a[1]), (a[0]) ; (a[1]) ; (a[2]) ; (a[3])) .
---red children((a[1]), andGraph) .
---red parents((a[4]), andGraph) .
---red (a[1]) in ((a[0]) ; (a[1]) ; (a[2])) .
---red (i[1]: 1) in allInd .
---red isActive((i[1]: 1)) .
---red removeInactive(1, someInd) .
---red getIndicator((a[1]), allInd) .
---red blockIndicator((i[1]: 1)) .
---red blockList((a[1]) ; (a[2]), allInd) .
---red parents((a[3]), xorGraph) .
---red children((a[1]), xorGraph) .
---red getXORParents((a[3]), parents((a[3]), xorGraph), xorGraph) .
---red getAllSiblings((a[3]), parents((a[3]), xorGraph), xorGraph) .
---red blockList(getXORParents((a[3]), parents((a[3]), xorGraph), xorGraph), allInd) .

---red getIndicator((a[2]), allInd) .
---red blockIndicator((i[2]: 1)) .

----red blockList(getAllSiblings((a[3]), parents((a[3]), xorGraph), xorGraph), allInd) .
---red blockList((a[2]), allInd) .
---red blockIndicatorList((a[3]), allInd, xorGraph) .
---red test((a[2]), (i[2]: 1)) .



*** PENDING: get the siblings
*** PENDING: test blockIndicators and related functions
*** PENDING: loop detection

--- CORRECT
---i am active and parent is active
---exists path from child to parent
---all nodes in path are active
---but no consecutive blocked nodes
--- -> empty IList(path) and add myself to list


--- INCORRECT
--- ! exists path from child to parent
--- !all nodes in path are active
--- consecutive blocked nodes
--- DISCARD