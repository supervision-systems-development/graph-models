*** Definition of Node types ***
fmod NTYPE is
  
  sort NType .
  ops nseq nand nor nxor : -> NType [ctor] .

endfm

*** Definition of execution status ***
fmod STATUS is

  sort Status .
  ops starting correct incorrect executing  : -> Status [ctor] .

endfm

*** Definition of a Graph ***
fmod GRAPH is
  pr NAT .
  pr INT .
  pr STRING .
  pr NTYPE .
  pr STATUS .

  --- Definition of a Graph
  sort Graph .
  op nil : -> Graph [ctor] .
  op _;;_ : Graph Graph -> Graph [assoc comm id: nil prec 50 ] .

  --- Definition of Nodes
  sort Node .
  ---subsort Node < Graph .
  op (n[_]:_) : Int NType -> Node [ctor prec 30] . --- Definition of Node. Has Id, Type and Function

  --- Definition of Arcs
  sort Arc .
  subsort Arc < Graph .
 --- op arcnil : -> Arc .
  op _->_ : Node Node -> Arc [ctor prec 30] . --- Definition of Arc. Unites two nodes.

  --- Definition of actions
  sort Action .
  subsort Action < ActionList .
  op (a[_]) : Int -> Action [ctor prec 30] . --- Definition of Action. Has Id

  --- Definition of a List of Actions
  sort ActionList .
  subsort ActionList < Graph . --- Definition of ActionList. List of Actions should be part of Graph
  op nil : -> ActionList [ctor] . 
  op _;_ : ActionList ActionList -> ActionList [assoc id: nil prec 30] . --- Definition of List of Actions.

  --- 
  sort Indicator .
  subsort Indicator < IndicatorList .
  op (i[_]:_) : Int Int -> Indicator [ctor prec 30] . --- Definition of Activation Indicator. Has Id of action and Indicator value (0, 1, -1) 

  ---
  sort IndicatorList .
  op nil : -> IndicatorList [ctor] .
  op _;_ : IndicatorList IndicatorList -> IndicatorList [assoc comm id: nil prec 30 ] .
  
endfm

*** Pre-defined graphs and sequences ***
fmod SEQUENCES is
  pr GRAPH .

  *** Graph configurations for testing ***
  --- Sequential graph
  op graph1 : -> Graph .
  eq graph1 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[2]: nseq) ->(n[-7]: nseq) .

  --- Sequential graph
  op graph2 : -> Graph .
  eq graph2 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nseq) ;;
    (n[3]: nseq) ->(n[4]: nseq) ;;
    (n[4]: nseq) ->(n[-7]: nseq) .
  
  --- And graph
  op graph3 : -> Graph .
  eq graph3 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nand) ;;
    (n[3]: nseq) ->(n[4]: nand) ;;
    (n[4]: nand) ->(n[-7]: nseq) .

  --- Or graph
  op graph4 : -> Graph .
  eq graph4 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nor) ;;
    (n[3]: nseq) ->(n[4]: nor) ;;
    (n[4]: nor) ->(n[-7]: nseq) .

  --- Xor graph
  op graph5 : -> Graph .
  eq graph5 = 
  	(n[-5]: nseq) ->(n[1]: nxor) ;;
    (n[1]: nxor) ->(n[2]: nseq) ;;
    (n[1]: nxor) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nseq) ;;
    (n[3]: nseq) ->(n[4]: nseq) ;;
    (n[4]: nseq) ->(n[-7]: nseq) .
  
  --- Xor graph
  op graph6 : -> Graph .
  eq graph6 = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nxor) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nxor) ->(n[4]: nseq) ;;
    (n[3]: nseq) ->(n[2]: nxor) ;;
    (n[3]: nseq) ->(n[4]: nseq) ;;
    (n[4]: nseq) ->(n[-7]: nseq) .

  --- Xor graph
  op xorTestingGraph : -> Graph .
  eq xorTestingGraph = 
    (n[1]: nseq) -> (n[2]: nseq) ;;
    (n[2]: nseq) -> (n[3]: nxor) ;;
    (n[3]: nxor) -> (n[4]: nseq) ;;
    (n[3]: nxor) -> (n[5]: nseq) ;;
    (n[5]: nseq) -> (n[6]: nor) ;;
    (n[4]: nseq) -> (n[6]: nor) ;;
    (n[6]: nor) -> (n[7]: nseq) ;;
    (n[6]: nor) -> (n[2]: nseq) .
  
  --- Graph with loop
  op smallLoopGraph : -> Graph .
  eq smallLoopGraph = 
    (n[-5]: nseq) ->(n[1]: nor) ;;
    (n[1]: nor) ->(n[2]: nseq) ;;
    (n[2]: nseq) ->(n[1]: nor) ;;
    (n[2]: nseq) ->(n[-7]: nseq) .

  --- Graph with loop
  op graphLoop : -> Graph .
  eq graphLoop = 
  	(n[-5]: nseq) ->(n[1]: nseq) ;;
    (n[1]: nseq) ->(n[2]: nseq) ;;
    (n[1]: nseq) ->(n[3]: nseq) ;;
    (n[2]: nseq) ->(n[4]: nseq) ;;
    (n[3]: nseq) ->(n[4]: nseq) ;;
    (n[4]: nseq) ->(n[5]: nseq) ;;
    (n[5]: nseq) ->(n[6]: nseq) ;;
    (n[6]: nseq) ->(n[-7]: nseq) ;;
    (n[5]: nseq) ->(n[1]: nseq) .
  
  --- Graph with loop
  op multiLoopGraph : -> Graph .
  eq multiLoopGraph =
  	(n[-5]: nseq) -> (n[1]: nseq) ;;
    (n[1]: nseq) -> (n[2]: nseq) ;;
    (n[1]: nseq) -> (n[3]: nor) ;;
    (n[2]: nseq) -> (n[4]: nseq) ;;
    (n[3]: nor) -> (n[4]: nseq) ;;
    (n[4]: nseq) -> (n[5]: nseq) ;;
    (n[5]: nseq) -> (n[6]: nor) ;;
    (n[6]: nor) -> (n[-7]: nseq) ;;
    (n[5]: nseq) -> (n[1]: nseq) ;;
    (n[6]: nor) -> (n[8]: nseq) ;;
    (n[8]: nseq) -> (n[9]: nseq) ;;
    (n[9]: nseq) -> (n[6]: nor) ;;
    (n[8]: nseq) -> (n[3]: nor) .
  
  ---
  op andGraph : -> Graph .
  eq andGraph =
    (n[-5]: nseq) -> (n[1]: nseq) ;;
    (n[1]: nseq) -> (n[2]: nseq) ;;
    (n[1]: nseq) -> (n[3]: nseq) ;;
    (n[2]: nseq) -> (n[4]: nand) ;;
    (n[3]: nseq) -> (n[4]: nand) ;;
    (n[4]: nand) -> (n[-7]: nseq) .

  *** Action sequences for testing ***
  op seq1 : -> ActionList .
  eq seq1 = (a[-5]) ; (a[1]) ; (a[2]) ; (a[-7]) .

  op seq2 : -> ActionList .
  eq seq2 = (a[-5]) ; (a[1]) ; (a[-7]) .

  op seq3 : -> ActionList .
  eq seq3 = (a[-5]) ; (a[1]) ; (a[2]) ; (a[3]) ; (a[4]) ; (a[-7]) .

  op seq4 : -> ActionList .
  eq seq4 = (a[-5]) ; (a[1]) ; (a[2]) ; (a[4]) ; (a[-7]) .

  ***
  op allInd : -> IndicatorList .
  eq allInd = (i[-5]: 1) ; (i[1]: 1) ; (i[2]: 1) ; (i[3]: 1) .

  op someInd : -> IndicatorList .
  eq someInd = (i[-5]: 1) ; (i[1]: 1) ; (i[2]: 1) .
  
endfm

*** Initial configurations ***
fmod CONFIG is
  pr SEQUENCES .

  *** Declaration of the configuration of our states ***
  sort Config .
  --- The configuration contains the following:
  --- List of actions performed
  --- List of activation indicators
  --- List of correctly performed actions
  --- List of incorrectly performed actions
  --- The sequence graph
  --- Indicator of the state of the execution
  op _|_|_|_|_|_ : ActionList IndicatorList ActionList ActionList Graph Status -> Config [ctor] . 

  *** Initial configurations using simple actions and graphs ***
  --- Sequential nodes (with artificial S and F nodes in a correct sequence) 
  op init-simple-correct : -> Config .
  eq init-simple-correct = 
    seq3 | 
    nil | 
    nil |
    nil |
    graph2 |
    starting .
endfm

fmod GRAPH-EQ is
  pr CONFIG .
  pr EXT-BOOL .

  *** Variables ***
  var AList AList' : ActionList . --- Lists of user actions
  var IList IList' : IndicatorList . --- Lists of Indicators
  var CList CList' : ActionList . --- Lists of correct actions
  var EList EList' : ActionList . --- Lists of incorrect actions
  var G G' G1 G2 : Graph . --- Graphs
  var type type' : NType . --- Node types
  var x y z n m : Int . --- Node ids

  *** Equations ***
  --- Check if the node is starting (-5) or fin (-7). If neither, is considered "other"
  op checkFunction : Action Graph -> String . 
  eq checkFunction((a[x]), G1 ;; (n[x]: type) -> (n[y]: type') ;; G2) = 
  	if x == -5
    then "start"
    else 
      if x == -7
      then "fin"
      else "oth"
      fi
    fi .
  
  --- Check if node is type "sequential", "and", "or" or "xor"
  op checkType : Action Graph -> String .
  eq checkType((a[x]), G1 ;; (n[x]: type) -> (n[y]: type') ;; G2) =
    if type == nand
    then "and"
    else 
      if type == nor
      then "or"
      else
        if type == nxor
        then "xor"
        else "seq"
        fi
      fi
    fi .

  ---
  ---op lastAction : ActionList -> Action .
  ---eq lastAction((AList ; (a[x]))) = (a[x]) .
  ---eq lastAction(nil) = nil .

  --- Activates indicator if not already active
  op activateIndicator : Int IndicatorList -> IndicatorList .
  eq activateIndicator(x, IList) = 
  if (i[x]: 1) in IList
  then 
    IList
  else 
    if (i[x]: -1) in IList --- If blocked, keep blocked
    then
      IList
    else 
      (i[x]: 1) ; IList
    fi
  fi .

  --- Return how many parents are in list of correct actions
  op activeParents : Action IndicatorList Graph -> String .
  eq activeParents((a[x]), IList, G) =
    if allIndicatorsActive(parents((a[x]), G), IList) == true
    then 
      "all"
    else 
      if someIndicatorsActive(parents((a[x]), G), IList) == true
      then "some"
      else "none"
      fi
    fi .

  *** Auxiliary Equations ***
  --- Action in List of Actions 
  op _in_ : Action ActionList -> Bool .
  eq (a[x]) in (AList ; (a[x]) ; AList') = true .
  eq (a[x]) in AList = false [owise] .

  --- Indicator in List of Indicators
  op _in_ : Indicator IndicatorList -> Bool .
  eq (i[x]: y) in (IList ; (i[x]: y) ; IList') = true .
  eq (i[x]: y) in IList = false [owise] .

  --- To obtain the list of direct parents of a node in a graph. -- returns parents
  op parents : Action Graph -> ActionList .
  eq parents((a[x]), (n[y]: type') -> (n[x]: type) ;; G) =
    (a[y]) ; parents((a[x]), G) .
  eq parents((a[x]), G) = nil [owise] .

  --- Check if all actions are in the target list of active actions
  op allIndicatorsActive : ActionList IndicatorList -> Bool .
  eq allIndicatorsActive(nil, IList) = true .
  eq allIndicatorsActive(((a[x]) ; AList), IList) =
    (not getIndicator((a[x]), IList) == (i[x]: 0)) and (getIndicator((a[x]), IList) in IList) and allIndicatorsActive(AList, IList) .
  
  --- Check if at least one of the actions is in the target list of active actions
  op someIndicatorsActive : ActionList IndicatorList -> Bool .
  eq someIndicatorsActive(nil, IList) = false .
  eq someIndicatorsActive(((a[x]) ; AList), IList) =
    (not getIndicator((a[x]), IList) == (i[x]: 0)) and (getIndicator((a[x]), IList) in IList) or someIndicatorsActive(AList, IList) .

  --- To obtain the list of direct children of a node in a graph.
  op children : Action Graph -> ActionList .
  eq children((a[x]), (n[x]: type) -> (n[x]: type') ;; G) =
    (a[x]) ; children((a[x]), G) .
  eq children((a[x]), G) = nil [owise] .

  --- Remove inactive indicator to substitute for active indicator
  op removeInactive : Int IndicatorList -> IndicatorList .
  eq removeInactive(x, IList ; (i[x]: 0) ; IList') = (IList ; IList') .

  ---
  op getIndicator : Action IndicatorList -> Indicator .
  eq getIndicator((a[x]), IList ; (i[x]: y) ; IList') = (i[x]: y) .
  eq getIndicator((a[x]), IList) = (i[x]: 0) [owise] .

  ---
  op isActive : Indicator -> Bool .
  eq isActive((i[x]: y)) =
    if y == 1
    then true
    else false
    fi .

endfm

mod GRAPH-RL is
  pr GRAPH-EQ .
  inc CONFIG .

  *** Variables ***
  var AList AList' : ActionList . --- Lists of user actions
  var IList IList' : IndicatorList . --- Lists of Indicators
  var CList CList' CList1 CList2 : ActionList . --- Lists of correct actions
  var EList EList' EList1 EList2 : ActionList . --- Lists of incorrect actions
  var G G' : Graph . --- Graphs
  var type type' : NType . --- Node types
  var x y z : Int . --- Node ids

  *** Rules ***
  --- Preliminary setup rule: Insert start and fin nodes into the graph (optional rule) 
  --- Requires consultation
  --- TO DO

  --- Start the execution: Transition status from "starting" to "executing" and consume starting action
  --- Actions start and fin are artificially inserted to control the sequences
  rl [start]: 
    (a[x]) ; AList | IList | CList | EList | G | starting  
    => 
    if checkFunction((a[x]), G) == "start"
    then
      AList | activateIndicator(x, IList) | (CList ; (a[x])) | EList | G | executing
	  else 
      AList | IList | CList | (EList ; (a[x])) | G | starting 
    fi .

  --- End the execution: Transition status from "executing" to "correct" or "incorrect"
  --- Check if the "fin" node is in the "CList" (correct list) and if so, set status as "correct"
  rl [end]:  
    nil | IList | CList ; (a[x]) | EList | G | executing
    =>
    if checkFunction((a[x]), G) == "fin"
    then
      nil | IList | CList | EList | G | correct 
    else 
      nil | IList | CList | EList | G | incorrect
    fi .
  
  ---
  rl [step] :
    (a[x]) ; AList | IList | CList | EList | G | executing
    => 
    if checkType((a[x]), G) == "and" and activeParents((a[x]), IList, G) == "all"
    then 
      AList | IList | (CList ; (a[x])) | EList | G | executing 
    else
      if not (checkType((a[x]), G) == "and") and activeParents((a[x]), IList, G) == "some"
      then 
        AList | IList | (CList ; (a[x])) | EList | G | executing 
      else
        AList | IList | CList | (EList ; (a[x])) | G | executing 
      fi
    fi .
  
endm

*** Testing functions ***
---red checkType((a[4]), andGraph) .
---red checkType((a[4]), andGraph) == "and" .
---red not (checkType((a[3]), andGraph) == "and") .
---red getIndicator((a[2]) ; (a[3]), allInd) .
---red not (getIndicator((a[3]), someInd) == (i[3]: 0)) .
---red parents((a[4]), andGraph) .
---red allIndicatorsActive((a[3]), someInd) .
---red activeParents((a[4]), someInd, andGraph) .
