*** Definition of Node types ***
fmod NTYPE is
  
  sort NType .
  ops genN andN orN xorN unkN : -> NType [ctor] .

endfm

*** Definition of Node function ***
fmod NFUNC is

  sort NFunc .
  ops str fin oth : -> NFunc [ctor] .

endfm

*** Definition of execution status ***
fmod STATUS is

  sort Status .
  ops correct incorrect executing starting : -> Status [ctor] .

endfm

*** Definition of a Graph ***
fmod GRAPH is
  pr NAT .
  pr INT .
  pr STRING .
  pr NTYPE .
  pr NFUNC .
  pr STATUS .

  --- Definition of a Graph
  sort Graph .
  op nil : -> Graph [ctor] . --- There was no [ctor]
  op _;_ : Graph Graph -> Graph [assoc comm id: nil prec 50 ] .

  *** A Graph is conformed by Arcs and Nodes ***
  --- Definition of a List of Nodes
  sort NodeList .
  subsort NodeList < Graph . --- List of Nodes should be part of Graph
  op nil : -> NodeList [ctor] . --- Definition of List of Nodes. There was no [ctor]
  op _,_ : NodeList NodeList -> NodeList [assoc id: nil] .

  --- Definition of Nodes
  sort Node .
  subsort Node < NodeList .
  op (n[_]:_,_) : Int NType NFunc -> Node [ctor] . --- Definition of Node. Has Id and Type

  --- Definition of Arcs
  sort Arc .
  subsort Arc < Graph .
  op _->_ : Node Node -> Arc [ctor prec 30] . --- Definition of Arc. Unites two nodes.

endfm

*** Initial configurations ***
fmod CONFIG is
  pr GRAPH .

  sort Config .
  op _|_|_|_|_ : NodeList NodeList NodeList Graph Status -> Config [ctor] .
  
  *** Variables ***
  var AList CList EList : NodeList .
  var G : Graph .
  var type : NType .
  var func : NFunc .
  var i : Int .

  *** Empty configuration ***
  op init-mt : -> Config .
  eq init-mt = nil | nil | nil | nil | executing .

  op init1 : -> Config .
  eq init1 = 
    (n[1]: genN, str), (n[2]: genN, fin) | 
    nil | 
    nil | 
    (n[1]: genN, str)->(n[2]: genN, fin) |
    starting .

  op init2 : -> Config .
  eq init2 = 
    (n[1]: genN, str), (n[3]: genN, oth), (n[2]: genN, oth), (n[4]: genN, fin) | 
    nil | 
    nil | 
    (n[1]: genN, str)->(n[2]: genN, oth); 
    (n[1]: genN, str)->(n[3]: genN, oth); 
    (n[2]: genN, oth)->(n[4]: andN, fin);
    (n[3]: genN, oth)->(n[4]: andN, fin)  |
    starting .


  op init3 : -> Config .
  eq init3 = 
    (n[1]: genN, str), (n[2]: genN, fin) | 
    nil | 
    nil | 
    (n[1]: genN, str)->(n[2]: genN, fin) |
    starting .



  op init11 : -> Config .
  eq init11 = 
    (n[1]: genN, str), (n[3]: genN, oth), (n[2]: genN, oth), (n[4]: genN, fin) | 
    nil | 
    nil | 
    (n[1]: genN, str)->(n[2]: genN, oth); 
    (n[1]: genN, str)->(n[3]: genN, oth); 
    (n[2]: genN, oth)->(n[4]: andN, fin);
    (n[3]: genN, oth)->(n[4]: andN, fin)  |
    starting .


  op init12 : -> Config . 
  eq init12 = seq1 | nil | nil | graph2 | starting .



  op init-seq-correct : -> Config .
  eq init-seq-correct = (n[1]: genN, str), (n[2]: genN, oth), (n[3]: genN, oth), (n[4]: genN, fin) | nil | nil | 
     (n[1]: genN, str)->(n[2]: genN, oth);
     (n[2]: genN, oth)->(n[3]: genN, oth);
     (n[3]: genN, oth)->(n[4]: genN, fin) | starting .
     
     
  op init-seq-incorrect : -> Config .
  eq init-seq-incorrect = (n[1]: genN, str), (n[2]: genN, oth), (n[3]: genN, oth), (n[4]: genN, fin) | nil | nil | 
     (n[1]: genN, str)->(n[2]: genN, oth);
     (n[2]: genN, oth)->(n[3]: genN, oth);
     (n[3]: genN, oth)->(n[5]: genN, fin) | starting .
     
  op init-or-incorrect : -> Config .
  eq init-or-incorrect = (n[1]: genN, str), (n[2]: genN, oth), (n[3]: genN, oth), (n[4]: genN, fin) | nil | nil | 
     (n[1]: genN, str)->(n[2]: genN, oth);
     (n[2]: genN, oth)->(n[3]: genN, oth);
     (n[3]: genN, oth)->(n[4]: genN, fin) | starting .
     
     
  op init-and-correct : -> Config .
  eq init-and-correct = (n[1]: genN, str), (n[2]: genN, oth), (n[3]: andN, oth), (n[4]: genN, fin) | nil | nil | 
     (n[1]: genN, str)->(n[2]: genN, oth);
	 (n[1]: genN, str)->(n[3]: andN, oth);
     (n[2]: genN, oth)->(n[3]: andN, oth);
     (n[3]: andN, oth)->(n[4]: genN, fin) | starting .


  op init-and-incorrect : -> Config .
  eq init-and-incorrect = (n[1]: genN, str), (n[3]: andN, oth), (n[4]: genN, fin) | nil | nil | 
     (n[1]: genN, str)->(n[2]: genN, oth);
	 (n[1]: genN, str)->(n[3]: andN, oth);
     (n[2]: genN, oth)->(n[3]: andN, oth);
     (n[3]: andN, oth)->(n[4]: genN, fin) | starting .



---- Various configs- first number indicates the graph, second number indicates the sequences




--- various sequences and graphs: 



  op graph1 : -> Graph .
  eq graph1 = 
  		(n[1]: genN, str)->(n[5]: genN, oth);
  		(n[5]: genN, oth)->(n[8]: genN, oth);
  		(n[8]: genN, oth)->(n[2]: genN, oth);
  		(n[2]: genN, oth)->(n[3]: genN, oth);
  		(n[3]: genN, oth)->(n[6]: genN, oth);
  		(n[6]: genN, oth)->(n[4]: genN, oth);
  		(n[6]: genN, oth)->(n[11]: genN, oth);
  		(n[4]: genN, oth)->(n[2]: genN, fin) .
        
        
   op graph2 : -> Graph .
   eq graph2 = 
  		(n[1]: genN, str)->(n[5]: genN, oth);
  		(n[5]: genN, oth)->(n[8]: genN, oth);
  		(n[8]: genN, oth)->(n[2]: genN, oth);
  		(n[2]: genN, oth)->(n[3]: genN, oth);
  		(n[3]: genN, oth)->(n[6]: genN, oth);
  		(n[6]: genN, oth)->(n[9]: genN, oth);
  		(n[6]: genN, oth)->(n[4]: genN, oth);
  		(n[6]: genN, oth)->(n[11]: genN, oth);
  		(n[4]: genN, oth)->(n[2]: genN, oth);
  		(n[9]: genN, oth)->(n[4]: genN, fin) .
        
        
        
    op graph3 : -> Graph .
    eq graph3 =
  		(n[1]: genN, str)->(n[5]: genN, oth);
  		(n[5]: genN, oth)->(n[8]: genN, oth);
  		(n[8]: genN, oth)->(n[2]: genN, oth);
  		(n[2]: genN, oth)->(n[3]: genN, oth);
  		(n[3]: genN, oth)->(n[6]: genN, oth);
  		(n[6]: genN, oth)->(n[9]: genN, oth);
  		(n[6]: genN, oth)->(n[11]: genN, oth);
  		(n[4]: genN, oth)->(n[2]: genN, oth);
  		(n[9]: genN, oth)->(n[4]: genN, fin) .


  op seq1 : -> NodeList .
        eq seq1 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[2]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq2 : -> NodeList .
        eq seq2 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq3 : -> NodeList .
        eq seq3 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq4 : -> NodeList .
        eq seq4 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq5 : -> NodeList .
        eq seq5 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq6 : -> NodeList .
        eq seq6 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq7 : -> NodeList .
        eq seq7 = (n[5]: genN, str), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq8 : -> NodeList .
        eq seq8 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq9 : -> NodeList .
        eq seq9 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq10 : -> NodeList .
        eq seq10 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq11 : -> NodeList .
        eq seq11 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq12 : -> NodeList .
        eq seq12 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[11]: genN, fin) .
  op seq13 : -> NodeList .
        eq seq13 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[2]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[11]: genN, fin) .
  op seq14 : -> NodeList .
        eq seq14 = (n[1]: genN, str), (n[1]: genN, oth), (n[4]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[6]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[11]: genN, fin) .
  op seq15 : -> NodeList .
        eq seq15 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[11]: genN, fin) .
  op seq16 : -> NodeList .
        eq seq16 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq17 : -> NodeList .
        eq seq17 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq18 : -> NodeList .
        eq seq18 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq19 : -> NodeList .
        eq seq19 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq20 : -> NodeList .
        eq seq20 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq21 : -> NodeList .
        eq seq21 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[11]: genN, fin) .
  op seq22 : -> NodeList .
        eq seq22 = (n[8]: genN, str), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq23 : -> NodeList .
        eq seq23 = (n[5]: genN, str), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq24 : -> NodeList .
        eq seq24 = (n[5]: genN, str), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq25 : -> NodeList .
        eq seq25 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq26 : -> NodeList .
        eq seq26 = (n[5]: genN, str), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[5]: genN, oth), (n[6]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[9]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq27 : -> NodeList .
        eq seq27 = (n[5]: genN, str), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq28 : -> NodeList .
        eq seq28 = (n[8]: genN, str), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[10]: genN, oth), (n[2]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq29 : -> NodeList .
        eq seq29 = (n[5]: genN, str), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq30 : -> NodeList .
        eq seq30 = (n[5]: genN, str), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq31 : -> NodeList .
        eq seq31 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[10]: genN, oth), (n[6]: genN, oth), (n[10]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq32 : -> NodeList .
        eq seq32 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq33 : -> NodeList .
        eq seq33 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[9]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq34 : -> NodeList .
        eq seq34 = (n[5]: genN, str), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq35 : -> NodeList .
        eq seq35 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[10]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq36 : -> NodeList .
        eq seq36 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq37 : -> NodeList .
        eq seq37 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq38 : -> NodeList .
        eq seq38 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
  op seq39 : -> NodeList .
        eq seq39 = (n[1]: genN, str), (n[1]: genN, oth), (n[5]: genN, oth), (n[8]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[4]: genN, oth), (n[2]: genN, oth), (n[3]: genN, oth), (n[6]: genN, oth), (n[11]: genN, fin) .
        
        
        
        ---- Various configs- first number indicates the graph, second number indicates the sequences



        
        
   op init1-1 : -> Config . 
          eq init1-1 = seq1 | nil | nil | graph1 | starting .
   op init1-2 : -> Config . 
          eq init1-2 = seq2 | nil | nil | graph1 | starting .
   op init1-3 : -> Config . 
          eq init1-3 = seq3 | nil | nil | graph1 | starting .
   op init1-4 : -> Config . 
          eq init1-4 = seq4 | nil | nil | graph1 | starting .
   op init1-5 : -> Config . 
          eq init1-5 = seq5 | nil | nil | graph1 | starting .
   op init1-6 : -> Config . 
          eq init1-6 = seq6 | nil | nil | graph1 | starting .
   op init1-7 : -> Config . 
          eq init1-7 = seq7 | nil | nil | graph1 | starting .
   op init1-8 : -> Config . 
          eq init1-8 = seq8 | nil | nil | graph1 | starting .
   op init1-9 : -> Config . 
          eq init1-9 = seq9 | nil | nil | graph1 | starting .
   op init1-10 : -> Config . 
          eq init1-10 = seq10 | nil | nil | graph1 | starting .
   op init1-11 : -> Config . 
          eq init1-11 = seq11 | nil | nil | graph1 | starting .
   op init1-12 : -> Config . 
          eq init1-12 = seq12 | nil | nil | graph1 | starting .
   op init1-13 : -> Config . 
          eq init1-13 = seq13 | nil | nil | graph1 | starting .
   op init1-14 : -> Config . 
          eq init1-14 = seq14 | nil | nil | graph1 | starting .
   op init1-15 : -> Config . 
          eq init1-15 = seq15 | nil | nil | graph1 | starting .
   op init1-16 : -> Config . 
          eq init1-16 = seq16 | nil | nil | graph1 | starting .
   op init1-17 : -> Config . 
          eq init1-17 = seq17 | nil | nil | graph1 | starting .
   op init1-18 : -> Config . 
          eq init1-18 = seq18 | nil | nil | graph1 | starting .
   op init1-19 : -> Config . 
          eq init1-19 = seq19 | nil | nil | graph1 | starting .
   op init1-20 : -> Config . 
          eq init1-20 = seq20 | nil | nil | graph1 | starting .
   op init1-21 : -> Config . 
          eq init1-21 = seq21 | nil | nil | graph1 | starting .
   op init1-22 : -> Config . 
          eq init1-22 = seq22 | nil | nil | graph1 | starting .
   op init1-23 : -> Config . 
          eq init1-23 = seq23 | nil | nil | graph1 | starting .
   op init1-24 : -> Config . 
          eq init1-24 = seq24 | nil | nil | graph1 | starting .
   op init1-25 : -> Config . 
          eq init1-25 = seq25 | nil | nil | graph1 | starting .
   op init1-26 : -> Config . 
          eq init1-26 = seq26 | nil | nil | graph1 | starting .
   op init1-27 : -> Config . 
          eq init1-27 = seq27 | nil | nil | graph1 | starting .
   op init1-28 : -> Config . 
          eq init1-28 = seq28 | nil | nil | graph1 | starting .
   op init1-29 : -> Config . 
          eq init1-29 = seq29 | nil | nil | graph1 | starting .
   op init1-30 : -> Config . 
          eq init1-30 = seq30 | nil | nil | graph1 | starting .
   op init1-31 : -> Config . 
          eq init1-31 = seq31 | nil | nil | graph1 | starting .
   op init1-32 : -> Config . 
          eq init1-32 = seq32 | nil | nil | graph1 | starting .
   op init1-33 : -> Config . 
          eq init1-33 = seq33 | nil | nil | graph1 | starting .
   op init1-34 : -> Config . 
          eq init1-34 = seq34 | nil | nil | graph1 | starting .
   op init1-35 : -> Config . 
          eq init1-35 = seq35 | nil | nil | graph1 | starting .
   op init1-36 : -> Config . 
          eq init1-36 = seq36 | nil | nil | graph1 | starting .
   op init1-37 : -> Config . 
          eq init1-37 = seq37 | nil | nil | graph1 | starting .
   op init1-38 : -> Config . 
          eq init1-38 = seq38 | nil | nil | graph1 | starting .
   op init1-39 : -> Config . 
          eq init1-39 = seq39 | nil | nil | graph1 | starting .
   op init2-1 : -> Config . 
          eq init2-1 = seq1 | nil | nil | graph2 | starting .
   op init2-2 : -> Config . 
          eq init2-2 = seq2 | nil | nil | graph2 | starting .
   op init2-3 : -> Config . 
          eq init2-3 = seq3 | nil | nil | graph2 | starting .
   op init2-4 : -> Config . 
          eq init2-4 = seq4 | nil | nil | graph2 | starting .
   op init2-5 : -> Config . 
          eq init2-5 = seq5 | nil | nil | graph2 | starting .
   op init2-6 : -> Config . 
          eq init2-6 = seq6 | nil | nil | graph2 | starting .
   op init2-7 : -> Config . 
          eq init2-7 = seq7 | nil | nil | graph2 | starting .
   op init2-8 : -> Config . 
          eq init2-8 = seq8 | nil | nil | graph2 | starting .
   op init2-9 : -> Config . 
          eq init2-9 = seq9 | nil | nil | graph2 | starting .
   op init2-10 : -> Config . 
          eq init2-10 = seq10 | nil | nil | graph2 | starting .
   op init2-11 : -> Config . 
          eq init2-11 = seq11 | nil | nil | graph2 | starting .
   op init2-12 : -> Config . 
          eq init2-12 = seq12 | nil | nil | graph2 | starting .
   op init2-13 : -> Config . 
          eq init2-13 = seq13 | nil | nil | graph2 | starting .
   op init2-14 : -> Config . 
          eq init2-14 = seq14 | nil | nil | graph2 | starting .
   op init2-15 : -> Config . 
          eq init2-15 = seq15 | nil | nil | graph2 | starting .
   op init2-16 : -> Config . 
          eq init2-16 = seq16 | nil | nil | graph2 | starting .
   op init2-17 : -> Config . 
          eq init2-17 = seq17 | nil | nil | graph2 | starting .
   op init2-18 : -> Config . 
          eq init2-18 = seq18 | nil | nil | graph2 | starting .
   op init2-19 : -> Config . 
          eq init2-19 = seq19 | nil | nil | graph2 | starting .
   op init2-20 : -> Config . 
          eq init2-20 = seq20 | nil | nil | graph2 | starting .
   op init2-21 : -> Config . 
          eq init2-21 = seq21 | nil | nil | graph2 | starting .
   op init2-22 : -> Config . 
          eq init2-22 = seq22 | nil | nil | graph2 | starting .
   op init2-23 : -> Config . 
          eq init2-23 = seq23 | nil | nil | graph2 | starting .
   op init2-24 : -> Config . 
          eq init2-24 = seq24 | nil | nil | graph2 | starting .
   op init2-25 : -> Config . 
          eq init2-25 = seq25 | nil | nil | graph2 | starting .
   op init2-26 : -> Config . 
          eq init2-26 = seq26 | nil | nil | graph2 | starting .
   op init2-27 : -> Config . 
          eq init2-27 = seq27 | nil | nil | graph2 | starting .
   op init2-28 : -> Config . 
          eq init2-28 = seq28 | nil | nil | graph2 | starting .
   op init2-29 : -> Config . 
          eq init2-29 = seq29 | nil | nil | graph2 | starting .
   op init2-30 : -> Config . 
          eq init2-30 = seq30 | nil | nil | graph2 | starting .
   op init2-31 : -> Config . 
          eq init2-31 = seq31 | nil | nil | graph2 | starting .
   op init2-32 : -> Config . 
          eq init2-32 = seq32 | nil | nil | graph2 | starting .
   op init2-33 : -> Config . 
          eq init2-33 = seq33 | nil | nil | graph2 | starting .
   op init2-34 : -> Config . 
          eq init2-34 = seq34 | nil | nil | graph2 | starting .
   op init2-35 : -> Config . 
          eq init2-35 = seq35 | nil | nil | graph2 | starting .
   op init2-36 : -> Config . 
          eq init2-36 = seq36 | nil | nil | graph2 | starting .
   op init2-37 : -> Config . 
          eq init2-37 = seq37 | nil | nil | graph2 | starting .
   op init2-38 : -> Config . 
          eq init2-38 = seq38 | nil | nil | graph2 | starting .
   op init2-39 : -> Config . 
          eq init2-39 = seq39 | nil | nil | graph2 | starting .
   op init3-1 : -> Config . 
          eq init3-1 = seq1 | nil | nil | graph3 | starting .
   op init3-2 : -> Config . 
          eq init3-2 = seq2 | nil | nil | graph3 | starting .
   op init3-3 : -> Config . 
          eq init3-3 = seq3 | nil | nil | graph3 | starting .
   op init3-4 : -> Config . 
          eq init3-4 = seq4 | nil | nil | graph3 | starting .
   op init3-5 : -> Config . 
          eq init3-5 = seq5 | nil | nil | graph3 | starting .
   op init3-6 : -> Config . 
          eq init3-6 = seq6 | nil | nil | graph3 | starting .
   op init3-7 : -> Config . 
          eq init3-7 = seq7 | nil | nil | graph3 | starting .
   op init3-8 : -> Config . 
          eq init3-8 = seq8 | nil | nil | graph3 | starting .
   op init3-9 : -> Config . 
          eq init3-9 = seq9 | nil | nil | graph3 | starting .
   op init3-10 : -> Config . 
          eq init3-10 = seq10 | nil | nil | graph3 | starting .
   op init3-11 : -> Config . 
          eq init3-11 = seq11 | nil | nil | graph3 | starting .
   op init3-12 : -> Config . 
          eq init3-12 = seq12 | nil | nil | graph3 | starting .
   op init3-13 : -> Config . 
          eq init3-13 = seq13 | nil | nil | graph3 | starting .
   op init3-14 : -> Config . 
          eq init3-14 = seq14 | nil | nil | graph3 | starting .
   op init3-15 : -> Config . 
          eq init3-15 = seq15 | nil | nil | graph3 | starting .
   op init3-16 : -> Config . 
          eq init3-16 = seq16 | nil | nil | graph3 | starting .
   op init3-17 : -> Config . 
          eq init3-17 = seq17 | nil | nil | graph3 | starting .
   op init3-18 : -> Config . 
          eq init3-18 = seq18 | nil | nil | graph3 | starting .
   op init3-19 : -> Config . 
          eq init3-19 = seq19 | nil | nil | graph3 | starting .
   op init3-20 : -> Config . 
          eq init3-20 = seq20 | nil | nil | graph3 | starting .
   op init3-21 : -> Config . 
          eq init3-21 = seq21 | nil | nil | graph3 | starting .
   op init3-22 : -> Config . 
          eq init3-22 = seq22 | nil | nil | graph3 | starting .
   op init3-23 : -> Config . 
          eq init3-23 = seq23 | nil | nil | graph3 | starting .
   op init3-24 : -> Config . 
          eq init3-24 = seq24 | nil | nil | graph3 | starting .
   op init3-25 : -> Config . 
          eq init3-25 = seq25 | nil | nil | graph3 | starting .
   op init3-26 : -> Config . 
          eq init3-26 = seq26 | nil | nil | graph3 | starting .
   op init3-27 : -> Config . 
          eq init3-27 = seq27 | nil | nil | graph3 | starting .
   op init3-28 : -> Config . 
          eq init3-28 = seq28 | nil | nil | graph3 | starting .
   op init3-29 : -> Config . 
          eq init3-29 = seq29 | nil | nil | graph3 | starting .
   op init3-30 : -> Config . 
          eq init3-30 = seq30 | nil | nil | graph3 | starting .
   op init3-31 : -> Config . 
          eq init3-31 = seq31 | nil | nil | graph3 | starting .
   op init3-32 : -> Config . 
          eq init3-32 = seq32 | nil | nil | graph3 | starting .
   op init3-33 : -> Config . 
          eq init3-33 = seq33 | nil | nil | graph3 | starting .
   op init3-34 : -> Config . 
          eq init3-34 = seq34 | nil | nil | graph3 | starting .
   op init3-35 : -> Config . 
          eq init3-35 = seq35 | nil | nil | graph3 | starting .
   op init3-36 : -> Config . 
          eq init3-36 = seq36 | nil | nil | graph3 | starting .
   op init3-37 : -> Config . 
          eq init3-37 = seq37 | nil | nil | graph3 | starting .
   op init3-38 : -> Config . 
          eq init3-38 = seq38 | nil | nil | graph3 | starting .
   op init3-39 : -> Config . 
          eq init3-39 = seq39 | nil | nil | graph3 | starting .
   
        
endfm

fmod GRAPH-EQ is
  pr CONFIG .

  *** Variables ***
  var NList NList1 NList2 : NodeList . --- Generic node list
  var AList AList1 AList2 : NodeList . --- Lists of user actions
  var CList CList1 CList2 : NodeList . --- Lists of correct actions
  var EList EList1 EList2 : NodeList . --- Lists of incorrect actions
  var G G1 G2 : Graph . --- Graphs
  var type type2 type1 type3 : NType . --- Node types
  var func func2 func1 func3 : NFunc . --- Node functions
  var i  x y : Int . --- Node ids
  var status : Status . --- Status of the execution
  var Arc1 Arc2 : Arc . --- arc varables
  var N1 N2 N3 N4 : Node . --- node variables

  *** Equations ***
  op checkStatus : NodeList -> Bool .
  eq checkStatus(nil) = false .
  eq checkStatus((CList, (n[i]: type, func))) = 
    if func == fin
    then true
    else false
    fi .

 --- Check if parents are in list of correct nodes
 op checkParentsInList : Node NodeList Graph -> Bool . --- check if ALL parents of a node are in the list of correct nodes
 eq checkParentsInList((n[i]: type, func), CList, G) =
    if isParentListInList(parents((n[i]: type, func), G), CList) 
    then true
    else false 
    fi .
    
    
 op allListInList : NodeList NodeList -> Bool .   
 eq allListInList(AList, NList) = isParentListInList(AList, NList) .
    
 op isParentListInList : NodeList NodeList -> Bool . --- isParentListInList checks if first list is completely in second list (isListInList). 
 eq isParentListInList(nil, CList) = true .			--- if the list is empty, then it is in every list and it returns true
 eq isParentListInList(((n[x]: type, func), NList), CList) =    --- if the first element of the list is in list
    if (n[x]: type, func) in CList    --- in operator in this case is vague
    then isParentListInList(NList, CList)   --- then check the rest of the elements of the list until there are no more elements left
    else false 									--- if the first element of a list is not in the second list, then it doesn't make sense to check the rest of the elements of the first list, as the first list is definitely not in the list
    fi .
    
    
 op isAtLeastOneListElementInList : NodeList NodeList -> Bool . --- checks if at least one element in the first list is in the second list (or)
 eq isAtLeastOneListElementInList(nil, CList) = true .			--- if the list is empty, then it is in every list and it returns true
 eq isAtLeastOneListElementInList(((n[x]: type, func), NList), CList) =    --- if the first element of the list is in list
    if (n[x]: type, func) in CList    --- "in" operator in this case is vague
    then true   --- then the "or" requirement is fulfilled
    else isAtLeastOneListElementInList(NList, CList) --- if the first element of a list is not in the second list, then check the rest of the first list
    fi .

 op atLeastOneInList : NodeList NodeList -> Bool .
 eq atLeastOneInList(AList, NList) = isAtLeastOneListElementInList (AList, NList) .


 op xor : NodeList NodeList -> Bool .
 eq xor(AList, NList) = 
 	if atLeastOneInList(AList, NList) and not allListInList(AList, NList)
    then true
    else false
    fi .


  *** Auxiliary equations ***
  --- To obtain the list of direct parents of a node in a graph.
  op parents : Node Graph -> NodeList .
  eq parents((n[i]: type, func), G1 ; (n[x]: type, func) -> (n[i]: type, func) ; G) =
    (n[x]: type, func) , parents((n[i]: type, func), G1 ; G) .
  eq parents((n[i]: type, func), G) = nil [owise] .

  op _in_ : Node NodeList -> Bool .
  eq (n[i]: type, func) in (NList1 , (n[i]: type, func) , NList2) = true .
  eq (n[i]: type, func) in NList1 = false [owise] .
  
  op getNodeType : Node Graph -> NType .  --- this function extracts the node type in the graph by NODE NUMBER ignoring everything else
  eq getNodeType((n[i]: type, func), (G1 ; ((n[x]: type2, func2)->(n[i]: type1, func1)) ; G2)) = type1 .
  
  op isThereAnEdge? : Node Node Graph -> Bool . --- is there an edge between two nodes in a graph? 
  eq isThereAnEdge?((n[i]: type, func), (n[x]: type1, func1), (G1 ; ((n[i]: type2, func2)->(n[x]: type3, func3)) ; G2)) = true .
  eq isThereAnEdge?(N1, N2, G1) = false [owise] .
  
  
  op parents2 : Node Graph -> NodeList
  eq parents2((n[i]: type, func), (((n[x]: type1, func1)->(n[y]: type2, func2)) ; G)) = 
  if (y == i)
  then ( (n[y]: type2, func2) , parents((n[i]: type, func), G)  )
  else (parents((n[i]: type, func), G)  )
  fi .
  
  
  
---  op checkSequenceWithGraph : NodeList Graph -> Bool .
---  eq checkSequenceWithGraph(NList, G) = 
---  	if (NList | CList | EList | G | correct)
---    then true
---    else false
---    fi .
  

endfm

mod GRAPH-RL is
  pr GRAPH-EQ .
  inc CONFIG .

  *** Variables ***
  var AList AList1 AList2 : NodeList . --- Lists of user actions
  var CList CList1 CList2 : NodeList . --- Lists of correct actions
  var EList EList1 EList2 : NodeList . --- Lists of incorrect actions
  var G G1 G2 : Graph . --- Graphs
  var type type1 type2 type3 typ4 : NType . --- Node types
  var func func1 func2 func3 : NFunc . --- Node functions
  var i x y z v : Int . --- Node ids
  var status : Status . --- Status of the execution



  *** Rules ***
  --- Start the execution

  rl [start]: --- this rule just changes the starting status into the executing status
    (n[i]: type, str), AList | CList | EList | G | starting  --- the first, artificially added START NODE is being moved to the correctly accepted sequence
    =>
    (n[i]: type, str), AList | CList | EList | G | executing . --- due to only integer numbers being used for node labels, it is decided to avoid artificial nodes and use the node property

  --- End the execution
  rl [end]:   --- this rule just changes the executing status into the finished correctly or incorrectly status
    nil | CList | EList | G | executing
    =>
    if checkStatus(CList)
    then
      nil | CList | EList | G | correct 
    else 
      nil | CList | EList | G | incorrect
    fi .

  --- Consume action when node is and type
  rl [step-and]:
    (n[i]: andN, func), AList | CList | EList | G | executing
    => 
    if checkParentsInList((n[i]: genN, func), CList, G)     --- if ALL parents of the node are in the Correct List
    then 
      AList | ( CList, (n[i]: andN, func) ) | EList | G | executing  --- then add the node to the list of Correct Nodes
    else
      AList | CList | (EList, (n[i]: andN, func)) | G | executing  --- otherwise add the node to the list of Error Nodes
    fi .

  rl [step-or]:        ---- space before colon creates problems
    (n[i]: orN, func), AList | CList | EList | G | executing  
    => 
    if isAtLeastOneListElementInList(							--- if at least one element from the list of parents of the node is in the list of Correct List, then
				parents((n[i]: orN, func), G),
				CList )
    then 
      AList | (CList, (n[i]: orN, func)) | EList | G | executing   --- add the node to the list of correct nodes
    else
      AList | CList | (EList, (n[i]: orN, func)) | G | executing  --- otherwise add the node to the list of incorrect nodes
    fi .


  rl [step-sequential]: 
    (n[i]: genN, func), AList | (CList, (n[x]: type1, func1)) | EList | G  | executing  --- if there is a simple node, just add it to the list of correct nodes
    => 
    if isThereAnEdge?((n[x]: type1, func1), (n[i]: genN, func), G)
    then
	AList | ((CList, (n[x]: type1, func1)), (n[i]: genN, func)) | EList | G | executing   --- add the node to the list of correct nodes
	else
   	AList | (CList, (n[x]: type1, func1)) | (EList, (n[i]: genN, func)) | G | executing   --- add the node to the list of incorrect nodes
    fi .
    
  rl [step-sequential-first]: 
    ((n[i]: type, str), AList) | nil | nil | G | executing  --- if there is a simple node, just add it to the list of correct nodes
    => 
    AList | (n[i]: type, str) | nil | G | executing   --- add the node to the list of correct nodes
	.


  rl [step-xor]:    --- for now we assume that every input with XOR is with 2 inputs and 
    (n[i]: xorN, func), AList | CList | EList | G | executing  
    => 
    if xor(
		parents((n[i]: orN, func), G),
		CList )
    then 
      AList | (CList, (n[i]: xorN, func)) | EList | G | executing   --- add the node to the list of correct nodes
    else
      AList | CList | (EList, (n[i]: xorN, func)) | G | executing  --- otherwise add the node to the list of incorrect nodes
    fi .

endm
