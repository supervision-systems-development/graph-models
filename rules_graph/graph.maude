*** Definition of Node types ***
fmod NTYPE is
  
  sort NType .
  ops nseq nand nor nxor nunk : -> NType [ctor] .

endfm

*** Definition of Node function ***
fmod NFUNC is

  sort NFunc .
  ops str fin oth : -> NFunc [ctor] .

endfm

*** Definition of execution status ***
fmod STATUS is

  sort Status .
  ops correct incorrect executing starting : -> Status [ctor] .

endfm

*** Definition of a Graph ***
fmod GRAPH is
  pr NAT .
  pr INT .
  pr STRING .
  pr NTYPE .
  pr NFUNC .
  pr STATUS .

  --- Definition of a Graph
  sort Graph .
  op nil : -> Graph [ctor] . --- There was no [ctor]
  op _;;_ : Graph Graph -> Graph [assoc comm id: nil prec 50 ] .

  *** A Graph is conformed by Arcs and Nodes ***
  --- Definition of a List of Nodes8
  sort NodeList .
  subsort NodeList < Graph . --- List of Nodes should be part of Graph
  op nil : -> NodeList [ctor] . --- Definition of List of Nodes. There was no [ctor]
  op _;_ : NodeList NodeList -> NodeList [assoc id: nil] .

  --- Definition of Nodes
  sort Node .
  subsort Node < NodeList .
  op (n[_]:_,_) : Int NType NFunc -> Node [ctor] . --- Definition of Node. Has Id and Type

  --- Definition of Arcs
  sort Arc .
  subsort Arc < Graph .
  op _->_ : Node Node -> Arc [ctor prec 30] . --- Definition of Arc. Unites two nodes.

endfm

*** Pre-defined graphs and sequences ***
fmod SEQUENCES is
  pr GRAPH .

  *** Graph configurations for testing ***
  --- Sequential graph
  op graph1 : -> Graph .
  eq graph1 = 
  	(n[0]: nseq, str)->(n[1]: nseq, oth);;
    (n[1]: nseq, oth)->(n[2]: nseq, oth);;
    (n[2]: nseq, oth)->(n[11]: nseq, fin) .

  --- Sequential graph
  op graph2 : -> Graph .
  eq graph2 = 
  	(n[0]: nseq, str)->(n[1]: nseq, oth);;
    (n[1]: nseq, oth)->(n[2]: nseq, oth);;
    (n[1]: nseq, oth)->(n[3]: nseq, oth);;
    (n[2]: nseq, oth)->(n[4]: nseq, oth);;
    (n[3]: nseq, oth)->(n[4]: nseq, oth);;
    (n[4]: nseq, oth)->(n[11]: nseq, fin) .
  
  --- And graph
  op graph3 : -> Graph .
  eq graph3 = 
  	(n[0]: nseq, str)->(n[1]: nseq, oth);;
    (n[1]: nseq, oth)->(n[2]: nseq, oth);;
    (n[1]: nseq, oth)->(n[3]: nseq, oth);;
    (n[2]: nseq, oth)->(n[4]: nand, oth);;
    (n[3]: nseq, oth)->(n[4]: nand, oth);;
    (n[4]: nand, oth)->(n[11]: nseq, fin) .

  --- Or graph
  op graph4 : -> Graph .
  eq graph4 = 
  	(n[0]: nseq, str)->(n[1]: nseq, oth);;
    (n[1]: nseq, oth)->(n[2]: nseq, oth);;
    (n[1]: nseq, oth)->(n[3]: nseq, oth);;
    (n[2]: nseq, oth)->(n[4]: nor, oth);;
    (n[3]: nseq, oth)->(n[4]: nor, oth);;
    (n[4]: nor, oth)->(n[11]: nseq, fin) .

  *** Action sequences for testing ***
  op seq1 : -> NodeList .
  eq seq1 = (n[0]: nseq, str); (n[1]: nseq, oth); (n[2]: nseq, oth); (n[11]: nseq, fin) .

  op seq2 : -> NodeList .
  eq seq2 = (n[0]: nseq, str); (n[1]: nseq, oth); (n[11]: nseq, fin) .

  op seq3 : -> NodeList .
  eq seq3 = (n[0]: nseq, str); (n[1]: nseq, oth); (n[2]: nseq, oth); (n[3]: nseq, oth); (n[4]: nseq, oth); (n[11]: nseq, fin) .

  op seq4 : -> NodeList .
  eq seq4 = (n[0]: nseq, str); (n[1]: nseq, oth); (n[2]: nseq, oth); (n[4]: nseq, oth); (n[11]: nseq, fin) .

endfm

*** Initial configurations ***
fmod CONFIG is
  pr SEQUENCES .

  sort Config .
  op _|_|_|_|_ : NodeList NodeList NodeList Graph Status -> Config [ctor] .
  
  *** Variables ***
  var AList CList EList : NodeList .
  var G : Graph .
  var type : NType .
  var func : NFunc .
  var i : Int .

  *** Initial configurations using simple actions and graphs ***
  --- Sequential nodes (with artificial S and F nodes in a correct sequence)
  op init-simple-correct : -> Config .
  eq init-simple-correct = 
    seq1 | 
    nil | 
    nil | 
    graph1 |
    starting .

  --- Sequential nodes (with artificial S and F nodes in an incorrect sequence)
  op init-simple-incorrect : -> Config .
  eq init-simple-incorrect = 
    seq2 | 
    nil | 
    nil | 
    graph1 |
    starting .

  --- Sequential nodes (with artificial S and F nodes in a correct sequence)
  op init-nseq-correct : -> Config .
  eq init-nseq-correct = 
    seq3 | 
    nil | 
    nil | 
    graph2 |
    starting .

  --- Sequential nodes with and node (with artificial S and F nodes in a correct sequence)
  op init-nand-correct : -> Config .
  eq init-nand-correct = 
    seq3 | 
    nil | 
    nil | 
    graph3 |
    starting .

  --- Sequential nodes with and node (with artificial S and F nodes in a correct sequence)
  op init-nand-incorrect : -> Config .
  eq init-nand-incorrect = 
    seq4 | 
    nil | 
    nil | 
    graph3 |
    starting .

  --- Sequential nodes with or node and both parents are accessed (with artificial S and F nodes in a correct sequence)
  op init-nor-correct1 : -> Config .
  eq init-nor-correct1 = 
    seq3 | 
    nil | 
    nil | 
    graph4 |
    starting .

  --- Sequential nodes with or node and one parent is accessed only (with artificial S and F nodes in a correct sequence)
  op init-nor-correct1 : -> Config .
  eq init-nor-correct1 = 
    seq4 | 
    nil | 
    nil | 
    graph4 |
    starting .
   
endfm

fmod GRAPH-EQ is
  pr CONFIG .
  pr EXT-BOOL .

  *** Variables ***
  var NList NList1 NList2 : NodeList . --- Generic node list
  var AList AList1 AList2 : NodeList . --- Lists of user actions
  var CList CList1 CList2 : NodeList . --- Lists of correct actions
  var EList EList1 EList2 : NodeList . --- Lists of incorrect actions
  var G G1 G2 : Graph . --- Graphs
  var type type2 type1 type3 : NType . --- Node types
  var func func2 func1 func3 : NFunc . --- Node functions
  var i j x y : Int . --- Node ids
  var status : Status . --- Status of the execution
  var Arc1 Arc2 : Arc . --- arc varables
  var N1 N2 N3 N4 : Node . --- node variables

  *** Equations ***
  --- Check if last node of Correct List is "fin" node
  op checkStatus : NodeList -> Bool .
  eq checkStatus(nil) = false .
  eq checkStatus((CList ; (n[i]: type, func))) = 
    if func == fin
    then true
    else false
    fi .

  --- Check if node is type "sequential", "and" or "or"
  op checkType : Node Graph -> String .
  eq checkType((n[i]: type, func), (n[i]: type1, func1) -> (n[x]: type2, func2);; G) =
    if type1 == nand
    then "and"
    else 
      if type1 == nor
      then "or"
      else "seq"
      fi
    fi .
  eq checkType((n[i]: type, func), (n[x]: type1, func1) -> (n[i]: type2, func2);; G) =
    if type2 == nand
    then "and"
    else 
      if type2 == nor
      then "or"
      else "seq"
      fi
    fi .

  --- Return how many parents are in list of correct actions
  op checkParentsInList : Node NodeList Graph -> String .
  eq checkParentsInList((n[i]: type, func), CList, G) =
    if allNodesListInList(parents((n[i]: type, func), G), CList) == true
    then 
      "all"
    else 
      if someNodesListInList(parents((n[i]: type, func), G), CList) == true
      then "some"
      else "none"
      fi
    fi .
  
  --- Check if all nodes are in the target list of nodes
  op allNodesListInList : NodeList NodeList -> Bool .
  eq allNodesListInList(nil, CList) = true .
  eq allNodesListInList(((n[x]: type, func); NList), CList) =
    ((n[x]: type, func) in CList) and allNodesListInList(NList, CList) .
  
  --- Check if at least one of the nodes is in the target list of nodes
  op someNodesListInList : NodeList NodeList -> Bool .
  eq someNodesListInList(nil, CList) = false .
  eq someNodesListInList(((n[x]: type, func); NList), CList) =
    ((n[x]: type, func) in CList) and someNodesListInList(NList, CList) .

  *** Auxiliary equations ***
  --- To obtain the list of direct parents of a node in a graph.
  op parents : Node Graph -> NodeList .
  eq parents((n[i]: type, func), (n[x]: type1, func1) -> (n[i]: type, func) ;; G) =
    (n[x]: type1, func1) ; parents((n[i]: type, func), G) .
  eq parents((n[i]: type, func), G) = nil [owise] .

  --- Check if requirements for "and" are met
  op checkAnd : Node NodeList Graph -> Bool .
  eq checkAnd((n[i]: type, func), CList, G) =
    if checkType((n[i]: type, func), G) == "and" and checkParentsInList((n[i]: type, func), CList, G) == "all"
    then true
    else false
    fi .

  --- Check if requirements for "and" are met
  op checkOr : Node NodeList Graph -> Bool .
  eq checkOr((n[i]: type, func), CList, G) =
    if checkType((n[i]: type, func), G) == "or" and checkParentsInList((n[i]: type, func), CList, G) == "some"
    then true
    else 
      if checkType((n[i]: type, func), G) == "or" and checkParentsInList((n[i]: type, func), CList, G) == "all"
      then true
      else false
      fi
    fi .

  --- Check if requirements for "and" are met
  op checkSeq : Node NodeList Graph -> Bool .
  eq checkSeq((n[i]: type, func), CList, G) =
    if checkType((n[i]: type, func), G) == "seq" and checkParentsInList((n[i]: type, func), CList, G) == "some"
    then true
    else 
      if checkType((n[i]: type, func), G) == "seq" and checkParentsInList((n[i]: type, func), CList, G) == "all"
      then true
      else false
      fi
    fi .
  
  op _in_ : Node NodeList -> Bool .
  eq (n[i]: type, func) in (NList1 ; (n[i]: type, func) ; NList2) = true .
  eq (n[i]: type, func) in NList1 = false [owise] .

  op isArc : Node Node Graph -> Bool .
  eq isArc((n[x]: type1, func1), (n[y]: type2, func2), nil) = false .
  eq isArc((n[x]: type1, func1), (n[y]: type2, func2), G1 ;; (n[x]: type1, func1) -> (n[y]: type2, func2) ;; G2) = true .
  eq isArc((n[x]: type1, func1), (n[y]: type2, func2), G) = false [owise] .

endfm

mod GRAPH-RL is
  pr GRAPH-EQ .
  inc CONFIG .

  *** Variables ***
  var AList AList1 AList2 : NodeList . --- Lists of user actions
  var CList CList1 CList2 : NodeList . --- Lists of correct actions
  var EList EList1 EList2 : NodeList . --- Lists of incorrect actions
  var G G1 G2 : Graph . --- Graphs
  var type type1 type2 type3 type4 : NType . --- Node types
  var func func1 func2 func3 func4 : NFunc . --- Node functions
  var i j x y z : Int . --- Node ids
  var status : Status . --- Status of the execution

  *** Rules ***
  --- Start the execution: Transition status from "starting" to "executing" and consume starting node
  --- Nodes str and fin nodes are artificial nodes inserted to control the sequences
  rl [start]: 
    (n[i]: nseq, str); AList | CList | EList | G | starting  
    =>
    AList | (CList ; (n[i]: nseq, str)) | EList | G | executing .

  --- End the execution: Transition status from "executing" to "correct" or "incorrect"
  --- Check if the "fin" node is in the "CList" (correct list) and if so, set status as "correct"
  rl [end]:  
    nil | CList | EList | G | executing
    =>
    if checkStatus(CList)
    then
      nil | CList | EList | G | correct 
    else 
      nil | CList | EList | G | incorrect
    fi .

  --- Consume action: Consume node
  --- Check what type of node we have found: "sequential", "and" or "or"
  rl [step] :
    (n[i]: type, func) ; AList | CList | EList | G | executing
    => 
    if checkAnd((n[i]: type, func), CList, G)
    then
      AList | (CList ; (n[i]: type, func)) | EList | G | executing 
    else
      if checkOr((n[i]: type, func), CList, G)
      then
        AList | (CList ; (n[i]: type, func)) | EList | G | executing 
      else
        if checkSeq((n[i]: type, func), CList, G)
        then
          AList | (CList ; (n[i]: type, func)) | EList | G | executing 
        else
          AList | CList | (EList ; (n[i]: type, func)) | G | executing 
        fi
      fi
    fi .
endm


*** Maude terminal tests ***
--- Search tests ---
---search init-simple-correct =>*  nil | CList | EList | G | correct .
---search init-simple-incorrect =>*  nil | CList | EList | G | incorrect .
---search init-nseq-correct =>*  nil | CList | EList | G | correct .
---search init-nand-correct =>*  nil | CList | EList | G | correct .
---search init-nor-correct1 =>*  nil | CList | EList | G | correct .

--- Reduce tests ---
---red checkParentsInList((n[4]: nseq, oth), (n[2]: nseq, oth) ; (n[3]: nseq, oth), (n[0]: nseq, str) -> (n[1]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[2]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[3]: nseq, oth) ;; (n[2]: nseq, oth) -> (n[4]: nseq, oth) ;; (n[3]: nseq, oth) -> (n[4]: nseq, oth) ;; (n[4]: nseq, oth) -> (n[11]: nseq, fin)) .
---red checkParentsInList((n[4]: nseq, oth), (n[2]: nseq, oth), (n[0]: nseq, str) -> (n[1]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[2]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[3]: nseq, oth) ;; (n[2]: nseq, oth) -> (n[4]: nseq, oth) ;; (n[3]: nseq, oth) -> (n[4]: nseq, oth) ;; (n[4]: nseq, oth) -> (n[11]: nseq, fin)) .
---red checkParentsInList((n[4]: nseq, oth), (n[11]: nseq, oth) ; (n[3]: nseq, oth), (n[0]: nseq, str) -> (n[1]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[2]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[3]: nseq, oth) ;; (n[2]: nseq, oth) -> (n[4]: nseq, oth) ;; (n[3]: nseq, oth) -> (n[4]: nseq, oth) ;; (n[4]: nseq, oth) -> (n[11]: nseq, fin)) .
---red allNodesListInList((n[1]: nseq, oth) ; (n[2]: nseq, oth) ; (n[3]: nseq, oth) ; (n[4]: nseq, oth), (n[2]: nseq, oth) ; (n[3]: nseq, oth)) .
---red allNodesListInList((n[2]: nseq, oth) ; (n[3]: nseq, oth), (n[1]: nseq, oth) ; (n[2]: nseq, oth) ; (n[3]: nseq, oth) ; (n[4]: nseq, oth)) .
---red someNodesListInList((n[1]: nseq, oth) ; (n[2]: nseq, oth) ; (n[3]: nseq, oth) ; (n[4]: nseq, oth), (n[2]: nseq, oth) ; (n[3]: nseq, oth)) .
---red someNodesListInList((n[2]: nseq, oth) ; (n[3]: nseq, oth), (n[1]: nseq, oth) ; (n[2]: nseq, oth) ; (n[3]: nseq, oth) ; (n[4]: nseq, oth)) .
---red parents((n[4]: nseq, oth), (n[0]: nseq, str) -> (n[1]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[2]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[3]: nseq, oth) ;; (n[2]: nseq, oth) -> (n[4]: nseq, oth) ;; (n[3]: nseq, oth) -> (n[4]: nseq, oth) ;; (n[4]: nseq, oth) -> (n[11]: nseq, fin)) .
---red parents((n[2]: nseq, oth), nil) .
---red isArc((n[1]: nseq, oth), (n[2]: nseq, oth), (n[0]: nseq, str) -> (n[1]: nseq, oth) ;;  (n[1]: nseq, oth) -> (n[2]: nseq, oth)  ;; (n[2]: nseq, oth) -> (n[11]: nseq, fin)) .
---red checkType((n[1]: nseq, oth), (n[0]: nseq, str) -> (n[1]: nor, oth) ;; (n[1]: nor, str) -> (n[2]: nseq, oth) ;; (n[2]: nseq, oth) -> (n[11]: nseq, fin)) .
--- red checkOr((n[4]: nseq, oth), (n[0]: nseq, str), (n[0]: nseq, str) -> (n[1]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[2]: nseq, oth) ;; (n[1]: nseq, oth) -> (n[3]: nseq, oth) ;; (n[2]: nseq, oth) -> (n[4]: nor, oth) ;; (n[3]: nseq, oth) -> (n[4]: nor, oth) ;; (n[4]: nor, oth) -> (n[11]: nseq, fin)) .

*** Troubleshooting of nand and nor ---
--- checkAnd and checkOr seem to work properly, but transition from those nodes to fin node has problems 
---red checkSeq((n[11]: nseq, fin), (n[0]: nseq, str); (n[1]: nseq, oth); (n[2]: nseq, oth); (n[3]: nseq, oth); (n[4]: nand, oth), graph3) .
---search (n[11]: type, func) | (n[0]: nseq, str); (n[1]: nseq, oth); (n[2]: nseq, oth); (n[3]: nseq, oth); (n[4]: nseq, oth) | nil | graph3 | executing => 
red checkType((n[11]: nseq, fin), graph3) .
red checkParentsInList((n[11]: nseq, fin), (n[0]: nseq, str); (n[1]: nseq, oth); (n[2]: nseq, oth); (n[3]: nseq, oth); (n[4]: nseq, oth), graph3) .
red parents((n[11]: nseq, fin), graph3) .
red someNodesListInList((n[4]: nseq, oth), (n[0]: nseq, str); (n[1]: nseq, oth); (n[2]: nseq, oth); (n[3]: nseq, oth); (n[4]: nseq, oth)) .